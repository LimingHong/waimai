<?php
 namespace GuzzleHttp\Promise; use Exception; use Generator; use Throwable; final class Coroutine implements PromiseInterface { private $currentPromise; private $generator; private $result; public function __construct(callable $generatorFn) { goto Ybk5w; Ybk5w: $this->generator = $generatorFn(); goto JBQf4; L7hzM: $this->nextCoroutine($this->generator->current()); goto HL7dA; JBQf4: $this->result = new Promise(function () { z5ucu: if (!isset($this->currentPromise)) { goto aBiub; } $this->currentPromise->wait(); goto z5ucu; aBiub: }); goto L7hzM; HL7dA: } public function then(callable $onFulfilled = null, callable $onRejected = null) { return $this->result->then($onFulfilled, $onRejected); } public function otherwise(callable $onRejected) { return $this->result->otherwise($onRejected); } public function wait($unwrap = true) { return $this->result->wait($unwrap); } public function getState() { return $this->result->getState(); } public function resolve($value) { $this->result->resolve($value); } public function reject($reason) { $this->result->reject($reason); } public function cancel() { $this->currentPromise->cancel(); $this->result->cancel(); } private function nextCoroutine($yielded) { $this->currentPromise = promise_for($yielded)->then([$this, "\137\x68\141\156\x64\154\x65\123\x75\143\x63\x65\x73\x73"], [$this, "\137\150\x61\x6e\x64\154\145\106\141\x69\154\165\162\145"]); } public function _handleSuccess($value) { unset($this->currentPromise); try { goto XZk_c; C82a8: goto zal0O; goto YB_Em; QBqhL: $this->result->resolve($value); goto C82a8; ZVZLi: zal0O: goto MasXp; YB_Em: Mvevv: goto ZOIlX; XZk_c: $next = $this->generator->send($value); goto FX_Qj; ZOIlX: $this->nextCoroutine($next); goto ZVZLi; FX_Qj: if ($this->generator->valid()) { goto Mvevv; } goto QBqhL; MasXp: } catch (Exception $exception) { $this->result->reject($exception); } catch (Throwable $throwable) { $this->result->reject($throwable); } } public function _handleFailure($reason) { unset($this->currentPromise); try { $nextYield = $this->generator->throw(exception_for($reason)); $this->nextCoroutine($nextYield); } catch (Exception $exception) { $this->result->reject($exception); } catch (Throwable $throwable) { $this->result->reject($throwable); } } }